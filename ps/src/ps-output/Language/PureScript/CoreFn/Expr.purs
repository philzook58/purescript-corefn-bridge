-- File auto generated by purescript-bridge! --
module Language.PureScript.CoreFn.Expr where

import Data.Either (Either)
import Data.Lens (Iso', Lens', Prism', lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype)
import Data.Symbol (SProxy(SProxy))
import Data.Tuple (Tuple)
import Language.PureScript.AST.Literals (Literal)
import Language.PureScript.CoreFn.Binders (Binder)
import Language.PureScript.Names (ConstructorName, Ident, ProperName, Qualified, TypeName)
import Prim (Array, String)

import Prelude
import Data.Generic (class Generic)

data Expr a =
    Literal a (Literal (Expr a))
  | Constructor a (ProperName TypeName) (ProperName ConstructorName) (Array Ident)
  | Accessor a String (Expr a)
  | ObjectUpdate a (Expr a) (Array (Tuple String (Expr a)))
  | Abs a Ident (Expr a)
  | App a (Expr a) (Expr a)
  | Var a (Qualified Ident)
  | Case a (Array (Expr a)) (Array (CaseAlternative a))
  | Let a (Array (Bind a)) (Expr a)

derive instance genericExpr :: Generic a => Generic (Expr a)


--------------------------------------------------------------------------------
_Literal :: forall a. Prism' (Expr a) { a :: a, b :: Literal (Expr a) }
_Literal = prism' (\{ a, b } -> Literal a b) f
  where
    f (Literal a b) = Just $ { a: a, b: b }
    f _ = Nothing

_Constructor :: forall a. Prism' (Expr a) { a :: a, b :: ProperName TypeName, c :: ProperName ConstructorName, d :: Array Ident }
_Constructor = prism' (\{ a, b, c, d } -> Constructor a b c d) f
  where
    f (Constructor a b c d) = Just $ { a: a, b: b, c: c, d: d }
    f _ = Nothing

_Accessor :: forall a. Prism' (Expr a) { a :: a, b :: String, c :: Expr a }
_Accessor = prism' (\{ a, b, c } -> Accessor a b c) f
  where
    f (Accessor a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_ObjectUpdate :: forall a. Prism' (Expr a) { a :: a, b :: Expr a, c :: Array (Tuple String (Expr a)) }
_ObjectUpdate = prism' (\{ a, b, c } -> ObjectUpdate a b c) f
  where
    f (ObjectUpdate a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_Abs :: forall a. Prism' (Expr a) { a :: a, b :: Ident, c :: Expr a }
_Abs = prism' (\{ a, b, c } -> Abs a b c) f
  where
    f (Abs a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_App :: forall a. Prism' (Expr a) { a :: a, b :: Expr a, c :: Expr a }
_App = prism' (\{ a, b, c } -> App a b c) f
  where
    f (App a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_Var :: forall a. Prism' (Expr a) { a :: a, b :: Qualified Ident }
_Var = prism' (\{ a, b } -> Var a b) f
  where
    f (Var a b) = Just $ { a: a, b: b }
    f _ = Nothing

_Case :: forall a. Prism' (Expr a) { a :: a, b :: Array (Expr a), c :: Array (CaseAlternative a) }
_Case = prism' (\{ a, b, c } -> Case a b c) f
  where
    f (Case a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_Let :: forall a. Prism' (Expr a) { a :: a, b :: Array (Bind a), c :: Expr a }
_Let = prism' (\{ a, b, c } -> Let a b c) f
  where
    f (Let a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

--------------------------------------------------------------------------------
data Bind a =
    NonRec a Ident (Expr a)
  | Rec (Array (Tuple (Tuple a Ident) (Expr a)))

derive instance genericBind :: Generic a => Generic (Bind a)


--------------------------------------------------------------------------------
_NonRec :: forall a. Prism' (Bind a) { a :: a, b :: Ident, c :: Expr a }
_NonRec = prism' (\{ a, b, c } -> NonRec a b c) f
  where
    f (NonRec a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_Rec :: forall a. Prism' (Bind a) (Array (Tuple (Tuple a Ident) (Expr a)))
_Rec = prism' Rec f
  where
    f (Rec a) = Just $ a
    f _ = Nothing

--------------------------------------------------------------------------------
newtype CaseAlternative a =
    CaseAlternative {
      caseAlternativeBinders :: Array (Binder a)
    , caseAlternativeResult :: Either (Array (Tuple (Expr a) (Expr a))) (Expr a)
    }

derive instance genericCaseAlternative :: Generic a => Generic (CaseAlternative a)

derive instance newtypeCaseAlternative :: Newtype (CaseAlternative a) _


--------------------------------------------------------------------------------
_CaseAlternative :: forall a. Iso' (CaseAlternative a) { caseAlternativeBinders :: Array (Binder a), caseAlternativeResult :: Either (Array (Tuple (Expr a) (Expr a))) (Expr a)}
_CaseAlternative = _Newtype

--------------------------------------------------------------------------------
