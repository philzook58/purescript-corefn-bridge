-- File auto generated by purescript-bridge! --
module Language.PureScript.Types where

import Data.Lens (Iso', Lens', Prism', lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe, Maybe(..))
import Data.Newtype (class Newtype)
import Data.Symbol (SProxy(SProxy))
import Language.PureScript.AST.SourcePos (SourceSpan)
import Language.PureScript.Kinds (Kind)
import Language.PureScript.Label (Label)
import Language.PureScript.Names (OpName, ProperName, Qualified, TypeName, TypeOpName)
import Language.PureScript.PSString (PSString)
import Prim (Array, Int, String)

import Prelude
import Data.Generic (class Generic)

data Type =
    TUnknown Int
  | TypeVar String
  | TypeLevelString PSString
  | TypeWildcard SourceSpan
  | TypeConstructor (Qualified (ProperName TypeName))
  | TypeOp (Qualified (OpName TypeOpName))
  | TypeApp Type Type
  | ForAll String Type (Maybe SkolemScope)
  | ConstrainedType Constraint Type
  | Skolem String Int SkolemScope (Maybe SourceSpan)
  | REmpty
  | RCons Label Type Type
  | KindedType Type Kind
  | PrettyPrintFunction Type Type
  | PrettyPrintObject Type
  | PrettyPrintForAll (Array String) Type
  | BinaryNoParensType Type Type Type
  | ParensInType Type

derive instance genericType :: Generic Type


--------------------------------------------------------------------------------
_TUnknown :: Prism' Type Int
_TUnknown = prism' TUnknown f
  where
    f (TUnknown a) = Just $ a
    f _ = Nothing

_TypeVar :: Prism' Type String
_TypeVar = prism' TypeVar f
  where
    f (TypeVar a) = Just $ a
    f _ = Nothing

_TypeLevelString :: Prism' Type PSString
_TypeLevelString = prism' TypeLevelString f
  where
    f (TypeLevelString a) = Just $ a
    f _ = Nothing

_TypeWildcard :: Prism' Type SourceSpan
_TypeWildcard = prism' TypeWildcard f
  where
    f (TypeWildcard a) = Just $ a
    f _ = Nothing

_TypeConstructor :: Prism' Type (Qualified (ProperName TypeName))
_TypeConstructor = prism' TypeConstructor f
  where
    f (TypeConstructor a) = Just $ a
    f _ = Nothing

_TypeOp :: Prism' Type (Qualified (OpName TypeOpName))
_TypeOp = prism' TypeOp f
  where
    f (TypeOp a) = Just $ a
    f _ = Nothing

_TypeApp :: Prism' Type { a :: Type, b :: Type }
_TypeApp = prism' (\{ a, b } -> TypeApp a b) f
  where
    f (TypeApp a b) = Just $ { a: a, b: b }
    f _ = Nothing

_ForAll :: Prism' Type { a :: String, b :: Type, c :: Maybe SkolemScope }
_ForAll = prism' (\{ a, b, c } -> ForAll a b c) f
  where
    f (ForAll a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_ConstrainedType :: Prism' Type { a :: Constraint, b :: Type }
_ConstrainedType = prism' (\{ a, b } -> ConstrainedType a b) f
  where
    f (ConstrainedType a b) = Just $ { a: a, b: b }
    f _ = Nothing

_Skolem :: Prism' Type { a :: String, b :: Int, c :: SkolemScope, d :: Maybe SourceSpan }
_Skolem = prism' (\{ a, b, c, d } -> Skolem a b c d) f
  where
    f (Skolem a b c d) = Just $ { a: a, b: b, c: c, d: d }
    f _ = Nothing

_REmpty :: Prism' Type Unit
_REmpty = prism' (\_ -> REmpty) f
  where
    f REmpty = Just unit
    f _ = Nothing

_RCons :: Prism' Type { a :: Label, b :: Type, c :: Type }
_RCons = prism' (\{ a, b, c } -> RCons a b c) f
  where
    f (RCons a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_KindedType :: Prism' Type { a :: Type, b :: Kind }
_KindedType = prism' (\{ a, b } -> KindedType a b) f
  where
    f (KindedType a b) = Just $ { a: a, b: b }
    f _ = Nothing

_PrettyPrintFunction :: Prism' Type { a :: Type, b :: Type }
_PrettyPrintFunction = prism' (\{ a, b } -> PrettyPrintFunction a b) f
  where
    f (PrettyPrintFunction a b) = Just $ { a: a, b: b }
    f _ = Nothing

_PrettyPrintObject :: Prism' Type Type
_PrettyPrintObject = prism' PrettyPrintObject f
  where
    f (PrettyPrintObject a) = Just $ a
    f _ = Nothing

_PrettyPrintForAll :: Prism' Type { a :: Array String, b :: Type }
_PrettyPrintForAll = prism' (\{ a, b } -> PrettyPrintForAll a b) f
  where
    f (PrettyPrintForAll a b) = Just $ { a: a, b: b }
    f _ = Nothing

_BinaryNoParensType :: Prism' Type { a :: Type, b :: Type, c :: Type }
_BinaryNoParensType = prism' (\{ a, b, c } -> BinaryNoParensType a b c) f
  where
    f (BinaryNoParensType a b c) = Just $ { a: a, b: b, c: c }
    f _ = Nothing

_ParensInType :: Prism' Type Type
_ParensInType = prism' ParensInType f
  where
    f (ParensInType a) = Just $ a
    f _ = Nothing

--------------------------------------------------------------------------------
